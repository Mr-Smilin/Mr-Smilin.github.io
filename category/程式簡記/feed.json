{
    "version": "https://jsonfeed.org/version/1",
    "title": "貓謎工坊 • All posts by \"程式簡記\" category",
    "description": "Code · Thinking · ACG",
    "home_page_url": "https://smilin.net",
    "items": [
        {
            "id": "https://smilin.net/2024/04/30/githubAction1/",
            "url": "https://smilin.net/2024/04/30/githubAction1/",
            "title": "Github Action 學習紀錄",
            "date_published": "2024-04-30T07:00:00.000Z",
            "content_html": "<h1 id=\"Auto-Pixai\"><a href=\"#Auto-Pixai\" class=\"headerlink\" title=\"Auto-Pixai\"></a>Auto-Pixai</h1><p><img src=\"https://raw.githubusercontent.com/Mr-Smilin/Auto-Pixai/main/public/pic/logo.png\" alt=\"auto-pixai\"></p>\n<p>之前撰寫的 <a href=\"https://github.com/Mr-Smilin/auto-pixai\">auto-pixai</a><br>經過多次調整，基本修復了大部分的 bug</p>\n<p>該專案透過爬蟲，<br>提供自動在 <a href=\"https://pixai.art/\">pixai</a> 簽到的功能</p>\n<p>考量到便利性，<br>將專案打包成 docker image，<br>實現無狀態的部屬環境，<br>最後透過 github tag 控制版本歷程。</p>\n<br>\n\n<h2 id=\"整合部屬需求\"><a href=\"#整合部屬需求\" class=\"headerlink\" title=\"整合部屬需求\"></a>整合部屬需求</h2><p>雖然 User 用起來是方便了，<br>但每次開發部版都需要進行複雜的手續..</p>\n<p>CI&#x2F;CD …好..好想要 CI&#x2F;CD 阿..<br>就在這麼想著的時候，想起了..</p>\n<p><strong>Github Action!</strong></p>\n<span id=\"more\"></span>\n\n<br>\n\n<h1 id=\"Github-Action\"><a href=\"#Github-Action\" class=\"headerlink\" title=\"Github Action\"></a>Github Action</h1><p><img src=\"/img/post/githubAction1/01.png\" alt=\"Github Action!\"></p>\n<p>Github Action 是 Github 提供的 CI&#x2F;CD 方案</p>\n<p>由 Github 提供整合環境，<br>在統一的無狀態環境下進行整合</p>\n<p>最重要的是，它對於 public repository 完全免費!</p>\n<p><a href=\"https://docs.github.com/zh/actions/quickstart\">Github Action 官方簡中文檔</a><br>在學習 github action 的過程，<br>官方文檔幫助了我許多</p>\n<p>因為有官方翻譯，在專有名詞的學習上也不容易被混淆。</p>\n<br>\n\n<h2 id=\"需求\"><a href=\"#需求\" class=\"headerlink\" title=\"需求?\"></a>需求?</h2><p><img src=\"/img/post/githubAction1/02.jpg\"></p>\n<p>做為 CI&#x2F;CD (自動整合&#x2F;自動部屬) 的角色，<br>我希望他可以在我推送 release 的時候，去做幾件事——</p>\n<ul>\n<li>根據 package.json 檢查版本</li>\n<li>自動創建新版本代號</li>\n<li>根據 Dockerfile 產出 Docker image</li>\n<li>將 image 標上版號，推至 Docker Hub</li>\n</ul>\n<p>並且由於 Github Action 還提供緩存功能，<br>如果將 <code>npm install</code> 拉到 Github Action，<br>搭配緩存可以有效縮短 Dockerfile 的產出時間與大小！</p>\n<p>配上 Github Action 的一些格式後，我們還需要——</p>\n<ul>\n<li>指定 <code>node</code> 版本</li>\n<li>緩存儲存 <code>node_modules</code></li>\n<li>緩存加載 <code>node_modules</code></li>\n</ul>\n<p>根據<a href=\"https://docs.github.com/zh/actions/using-workflows/caching-dependencies-to-speed-up-workflows\">官方文檔</a>所述，<br>7 天沒使用的 cache 會自動回收，<br>並且一個 repository 的所有 cache 加總不可超出 10GB</p>\n<p>除此以外，緩存沒有任何限制</p>\n<pre><code>- name: Cache node modules\n        id: cache-node-modules\n        uses: actions/cache@v3\n        with:\n          path: node_modules\n          key: $&#123;&#123; runner.os &#125;&#125;-node-$&#123;&#123; hashFiles('**/package-lock.json') &#125;&#125;\n          restore-keys: |\n            $&#123;&#123; runner.os &#125;&#125;-node-\n</code></pre>\n<p>根據 package-lock.json 的變動來決定是否新建緩存，<br>否則就取出原本的 node_modules，<br>以此加速 CD 流程。</p>\n<br>\n\n<h2 id=\"過程\"><a href=\"#過程\" class=\"headerlink\" title=\"過程\"></a>過程</h2><p><img src=\"/img/post/githubAction1/03.jpg\"></p>\n<p>搭啷，經過整理後，<br>這是目前的 CI&#x2F;CD 流程</p>\n<p>由於沒有實作測試，<br>僅有 release 被推送時需要 CI&#x2F;CD</p>\n<p>執行首先檢查 tag ，<br>若 package 版號有變動則創建新版本</p>\n<p>同時進行 cache 的載入，<br>若是找不到 cache 則重新 <code>npm install</code></p>\n<p>兩邊都做完後，<br>進行 Dockerfile 的 building 與 pushing。</p>\n<br>\n\n<h2 id=\"結果\"><a href=\"#結果\" class=\"headerlink\" title=\"結果\"></a>結果</h2><p>大功告成！原本繁瑣的整合部屬流程</p>\n<ul>\n<li>Push New Version</li>\n<li>Dockerfile build</li>\n<li>Docker image tag</li>\n<li>Docker push tag</li>\n<li>Docker push latest</li>\n<li>…</li>\n</ul>\n<p>上面列的事情 <strong>通通不用</strong></p>\n<p>只要在 main 寫完代碼，<br>要推送版本的時候合併到 release，<br>最後再用自動產生的 tag 生成 Release 說明即可。</p>\n<br>\n\n<h1 id=\"結語\"><a href=\"#結語\" class=\"headerlink\" title=\"結語\"></a>結語</h1><p>怎麼說呢…好爽</p>\n<p>不過所謂爬蟲簽到甚麼的，<br>說白了只是個小工具</p>\n<p>藉著這次 project，<br>心血來潮地想把 repository 弄得有模有樣</p>\n<p>結果就是，<br>花在打扮(?)外觀的時間遠遠超出了爬蟲本身的開發時間</p>\n<p>感覺對 CICD 有了更深刻的了解；<br>美中不足的大概是爬蟲的測試並不好寫，<br>沒能在這次 action 中寫入自動測試，是比較可惜的。</p>\n",
            "tags": [
                "github",
                "CI/CD"
            ]
        },
        {
            "id": "https://smilin.net/2024/04/23/shareButton1/",
            "url": "https://smilin.net/2024/04/23/shareButton1/",
            "title": "使用 AddToAny 分享箱，踩雷過程",
            "date_published": "2024-04-23T10:00:00.000Z",
            "content_html": "<p><img src=\"/img/post/shareButton1/01.jpg\"></p>\n<p>網站之前有配置分享箱的系統，使用 <a href=\"https://github.com/overtrue/share.js\">sharejs</a> 依賴<br>該依賴只要套上預設即可，十分方便</p>\n<p>不過 sharejs 最新的 release 已經是 2016 年的事了…</p>\n<p>實際上有些按鈕已經過時，無法使用</p>\n<span id=\"more\"></span>\n\n<p><a href=\"https://ppoffice.github.io/hexo-theme-icarus/Plugins/Share/icarus%E7%94%A8%E6%88%B7%E6%8C%87%E5%8D%97-%E5%88%86%E4%BA%AB%E6%8C%89%E9%92%AE\">關於本主題的分享箱適配</a></p>\n<p>icarus 本身是支援多種分享功能的<br>由於 sharejs 停止維護，官方建議採用別的分享功能</p>\n<br>\n\n<hr>\n<h1 id=\"AddToAny\"><a href=\"#AddToAny\" class=\"headerlink\" title=\"AddToAny\"></a>AddToAny</h1><p><img src=\"/img/post/shareButton1/addtoany_logo.svg\" alt=\"addtoany\"></p>\n<p>看了一圈，決定改用 <a href=\"https://www.addtoany.com/\">AddToAny</a></p>\n<p>其一是因為該插件支援的社群足夠多，有持續在維護</p>\n<p>與 blog 代碼沒甚麼交集，自定義客製方便</p>\n<br>\n\n<hr>\n<h1 id=\"踩雷過程\"><a href=\"#踩雷過程\" class=\"headerlink\" title=\"踩雷過程\"></a>踩雷過程</h1><p>簡單選一下想要的按鈕，產出代碼後，扔進 jsx 內</p>\n<p>到此就搞定了(超快~)，build 看下輸出</p>\n<p><img src=\"/img/post/shareButton1/02.jpg\"></p>\n<p>hmmm…為什麼會是一片空白呢？</p>\n<br>\n\n<hr>\n<h2 id=\"沒有-CSS\"><a href=\"#沒有-CSS\" class=\"headerlink\" title=\"沒有 CSS ?\"></a>沒有 CSS ?</h2><p>看了一下，似乎是 css 沒有載入</p>\n<p>不過 css 這些內容應該會隨著 js 一併輸出才對</p>\n<p>花了些時間尋找問題，之後發現</p>\n<p><img src=\"/img/post/shareButton1/03.jpg\"></p>\n<p>原來是被瀏覽器擋住了，會被瀏覽器攔截主要有幾個可能性</p>\n<ul>\n<li>混和內容(Mixed Content):<br>如果網站是透過 HTTPS 協定提供服務的，而嘗試載入的資源（如 page.js）使用的是 HTTP 鏈接，那麼這種「混合內容」可能會被現代瀏覽器封鎖。 確保所有外部載入的資源都使用 HTTPS 來避免這種問題。</li>\n<li>安全策略(CSP):<br>瀏覽器可能會因為安全策略(Content Security Policy)而阻止某些腳本的載入。</li>\n<li>跨域問題(CORS):<br>服務商有可能因為沒有提供適當的跨域策略(Cross-Origin Resource Sharing)，導致資源無法載入</li>\n<li>廣告攔截器:<br>一些廣告攔截器或安全相關的瀏覽器擴充功能可能會阻止諸如 AddToAny 這樣的第三方服務。</li>\n</ul>\n<p>由於我們網站跟 AddToAny 都是 https，第一點可以排除<br>本站並沒有設置 CSP (目前沒有)<br>AddToAny 這類插件沒處理好 CORS 的機率是很低的</p>\n<p>簡單排除後，比較有可能的是被廣告攔截器擋住了</p>\n<br>\n\n<p><img src=\"/img/post/shareButton1/04.jpg\"></p>\n<p>喔喔喔！總算出來了！</p>\n<br>\n\n<hr>\n<h2 id=\"廣告攔截器\"><a href=\"#廣告攔截器\" class=\"headerlink\" title=\"廣告攔截器\"></a>廣告攔截器</h2><p>試了分享功能正常，就是按鈕有點多<br>可能減少一些..之後客製 style…</p>\n<p>恩..不過這樣好像沒有解決問題阿？</p>\n<p>根據統計，全世界有至少<strong>四成</strong>的人口，常駐廣告攔截器在上網</p>\n<p>只是我看的到而已，如果其他人看不到的話就沒意義了 qq</p>\n<p>不過攔截的問題還算好解決，只要讓他不會被攔截就好了！(廢話)</p>\n<p>方法很多，最簡單的是將原本被攔截的檔案納入網域下<br>載入原本就是同域名下的資源，通常就能繞過限制了。</p>\n<pre><code>&lt;script async src=&quot;https://static.addtoany.com/menu/page.js&quot; defer=&#123;true&#125;&gt;&lt;/script&gt;\n</code></pre>\n<p>根據產出的代碼來看，主要是這個檔案需要拉進來</p>\n<p><img src=\"/img/post/shareButton1/05.jpg\"></p>\n<p>整理格式，創建一個 addtoany.js 放進去<br>以 hexo 來說就是將 js 檔案放在 <code>themes/&#123;theme_name&#125;/source/js</code> 底下</p>\n<p>之後回到 addtoany.jsx 修改來源</p>\n<pre><code>&lt;script async src=&quot;/js/addtoany.js&quot; defer=&#123;true&#125;&gt;&lt;/script&gt;\n</code></pre>\n<p>RUN！</p>\n<p><img src=\"/img/post/shareButton1/02.jpg\"></p>\n<p>失敗了！</p>\n<p><img src=\"/img/post/shareButton1/06.jpg\"></p>\n<p>載入失敗的檔案反而變多了！</p>\n<br>\n\n<hr>\n<h2 id=\"更多的廣告\"><a href=\"#更多的廣告\" class=\"headerlink\" title=\"更多的廣告\"></a>更多的廣告</h2><p>看了下失敗的內容，來源都是出自 addtoany.js，也就是剛剛新增的檔案</p>\n<p>回頭翻代碼…</p>\n<p><img src=\"/img/post/shareButton1/07.jpg\"></p>\n<p><img src=\"/img/post/shareButton1/08.jpg\"></p>\n<p>看來是原本的 page.js 引入了其他檔案<br>然後其他檔案又被攔截了…</p>\n<p>雖然有點亂，但還是好解決的</p>\n<p>首先在 <code>source</code> 目錄新增 <code>addtoany</code> 資料夾<br>將 <code>addtoany.js</code> 改名回 <code>page.js</code> ，放進 <code>addtoany</code> 資料夾<br>原本 <code>addtoany.jsx</code> 的 script 也要修改</p>\n<pre><code>&lt;script async src=&quot;/addtoany/page.js&quot; defer=&#123;true&#125;&gt;&lt;/script&gt;\n</code></pre>\n<p>之後將三個攔截的檔案拷貝整理後，在 <code>source/addtoany</code> 創建同名檔案</p>\n<p>然後..然後…<br>然後在 <code>core.js</code> 引用了更多會被攔截的 url…</p>\n<p>估計是進行一些第三方 icon 的載入等等…</p>\n<br>\n\n<hr>\n<br>\n\n<h1 id=\"結語\"><a href=\"#結語\" class=\"headerlink\" title=\"結語\"></a>結語</h1><p><img src=\"/img/post/shareButton1/09.jpg\"></p>\n<p>重新修改 <code>core.js</code> 的代碼，最終是成功了</p>\n<p>但是<br>修改已經壓縮過的代碼，過程是麻煩且沒營養的<br>處理方法相當於暴力破解，也不排除往後產生其他 ERROR 的可能，故這邊不多贅述———</p>\n<br>\n\n<hr>\n<p>如果有幸你也在想辦法處理 AddToAny 的問題，又懶得架 cdn 等方式</p>\n<p>這邊提供整理後的檔案，歡迎參考。</p>\n<p><a href=\"/share_file/shareButton1/addtoany.7z\">addtoany.7z</a></p>\n<p>MD5: <code>e4c6ac982c223e6449d1d962be077bfb</code><br>SHA1: <code>a9cc39cc5e9a7d0854d63b15a4801829c1718efb</code></p>\n",
            "tags": [
                "hexo",
                "addtoany"
            ]
        },
        {
            "id": "https://smilin.net/2024/04/13/autoPixai/",
            "url": "https://smilin.net/2024/04/13/autoPixai/",
            "title": "自動領取 Pixai 每日獎勵",
            "date_published": "2024-04-13T11:00:00.000Z",
            "content_html": "<p><img src=\"/img/post/autoPixai/01.jpg\" alt=\"title\"></p>\n<p>工程網址<br><a href=\"https://github.com/Mr-Smilin/auto-pixai\">Github</a><br><a href=\"https://hub.docker.com/r/smile0301/auto-pixai\">Docker Hub</a></p>\n<p>近幾年 AI 工具日新月異<br>我也有幸接觸了 AI 繪圖的一鱗半爪</p>\n<p>其中 <a href=\"https://pixai.art/\">pixai</a> 是少有的雲端免費算圖網站</p>\n<p>在 pixai 如果對產出來的圖感到滿意的話<br>可以透過 AI 進一步運算，產出會動的圖</p>\n<span id=\"more\"></span>\n\n<hr>\n<br>\n\n<p>說是免費，其實還是有些限制的</p>\n<p>在網站上的運算行為都需要消耗點數，無論是靜態或動態</p>\n<p>而點數除了透過付費與活動取得以外<br>pixai 每日都有一萬點數可供會員領取，也就是每日獎勵</p>\n<p><img src=\"/img/post/autoPixai/02.jpg\" alt=\"每日獎勵\"></p>\n<p>只要每天領取就可以免費算圖了，整個佛心來著對吧</p>\n<p>不過筆者最喜歡花費幾個小時來搞定原本一分鐘可以做到的事情(x</p>\n<hr>\n<br>\n\n<p><a href=\"https://github.com/Mr-Smilin/auto-pixai\">auto-pixai</a></p>\n<p>輸入帳號跟密碼，該腳本執行一次就會自動進網站領取每日獎勵</p>\n<p>使用 node.js 撰寫，另有 Docker 容器化，開箱即用</p>\n<pre><code>docker pull smile0301/auto-pixai\ndocker run -e LOGINNAME=&lt;你的帳號&gt; -e PASSWORD=&lt;你的密碼&gt; --name &lt;container-name&gt; smile0301/auto-pixai\n</code></pre>\n",
            "tags": [
                "node.js",
                "教學",
                "docker"
            ]
        },
        {
            "id": "https://smilin.net/2023/10/27/rust_learning_02/",
            "url": "https://smilin.net/2023/10/27/rust_learning_02/",
            "title": "Rust 學習紀錄[2] = Rust 的 NPM",
            "date_published": "2023-10-27T13:00:00.000Z",
            "content_html": "<p>讓我們接著原本的進度繼續</p>\n<span id=\"more\"></span>\n\n<br>\n\n<h1 id=\"Cargo\"><a href=\"#Cargo\" class=\"headerlink\" title=\"Cargo\"></a>Cargo</h1><br>\n\n<p><code>Cargo</code> 是 <code>Rust</code> 的專案建置工具以及套件管理器<br>恩..聽起來是個 <code>npm</code></p>\n<p>我們在安裝 <code>rustup</code> 時已經一併安裝了 <code>Cargo</code><br>使用 <code>cargo --version</code> 來確認是否正確安裝</p>\n<pre><code>cargo --version // cargo 1.73.0 (9c4383fb5 2023-08-26)\n</code></pre>\n<p>沒問題的話，接著使用 <code>Cargo</code> 創建跟昨天相似的專案。</p>\n<br>\n\n<h1 id=\"創建專案\"><a href=\"#創建專案\" class=\"headerlink\" title=\"創建專案\"></a>創建專案</h1><br>\n\n<p>在專案目錄(rust_project)下輸入創建專案的指令</p>\n<p><code>cargo new _02_hello_cargo</code></p>\n<p>現在我們有名為 <code>_02_hello_cargo</code> 的資料夾，裡面結構如下</p>\n<pre><code>src\n  main.rs\n.gitignore\nCargo.toml\n</code></pre>\n<p><code>src</code> - 常見程式開發檔案目錄，看就知道</p>\n<p><code>src\\main.rs</code> - 主程式</p>\n<p><code>.gitignore</code> - git 的描述文件，主要功能是防止裡面提到的檔案在 git 傳輸時被包進去(Ex:log&#x2F;target)</p>\n<p><code>Cargo.toml</code> - 打開來看了下，應該是專案描述文件，對應 node 的 <code>package.json</code></p>\n<br>\n\n<h2 id=\"編譯-build\"><a href=\"#編譯-build\" class=\"headerlink\" title=\"編譯(build)\"></a>編譯(build)</h2><br>\n\n<p>試著 build 起這個專案看看<br><code>cargo build</code></p>\n<p>執行後，專案內多出了幾個檔案</p>\n<pre><code>target\n  debug\n    _02_hello_cargo.exe\n    more debug files...\n  .rustc_info.json\n  CACHEDIR.TAG\nCargo.lock\n</code></pre>\n<p><code>Cargo.lock</code> - 對應 node 的 <code>package-lock.json</code></p>\n<p><code>target\\debug\\_02_hello_cargo.exe</code> - 我們產出的執行檔，debug 大概是 building 的默認方式，之後應該會有相對嚴謹的方法</p>\n<pre><code>.\\target\\debug\\_02_hello_cargo // Hello, world!\n</code></pre>\n<br>\n\n<h2 id=\"編譯並運行-run\"><a href=\"#編譯並運行-run\" class=\"headerlink\" title=\"編譯並運行(run)\"></a>編譯並運行(run)</h2><br>\n\n<p>Cargo 有提供一種命令，可以將編譯與運行合併成一個指令</p>\n<pre><code>cargo run // Hello, world!\n</code></pre>\n<p>如果開發檔案沒有修改，<code>cargo run</code> 不會重建 target<br>加上合併兩個步驟，比 <code>cargo build</code> 方便許多。</p>\n<br>\n\n<h2 id=\"檢查-check\"><a href=\"#檢查-check\" class=\"headerlink\" title=\"檢查(check)\"></a>檢查(check)</h2><br>\n\n<p>除了編譯與運行，Cargo 當然也提供了檢查命令</p>\n<pre><code>cargo check\n  /**\n    Checking _02_hello_cargo v0.1.0(C:\\my\\01\\git\\rust\\_02_hello_cargo)\n    Finished dev [unoptimized + debuginfo] target(s) in 0.07s\n  **/\n</code></pre>\n<p>單純的 <code>check</code> 比 <code>build</code> 快上許多<br>在自動化部屬等一類場景中廣泛運用。</p>\n<br>\n\n<h2 id=\"正式編譯-release\"><a href=\"#正式編譯-release\" class=\"headerlink\" title=\"正式編譯(release)\"></a>正式編譯(release)</h2><br>\n\n<pre><code>cargo build --release\n  /**\n    Compiling _02_hello_cargo v0.1.0 (C:\\my\\01\\git\\rust\\_02_hello_cargo)\n        Finished release [optimized] target(s) in 0.36s\n  **/\n</code></pre>\n<p>使用 <code>--release</code> building 的檔案會放在 <code>target\\release</code><br>與 debug 版本不同，release 的編譯過程比較久，但會最佳化產出的結果</p>\n<p>因此，使用 debug 開發可以有效降低等待編譯的時間<br>需要發佈檔案時，再使用 release。</p>\n<br>\n\n<h1 id=\"今日小結\"><a href=\"#今日小結\" class=\"headerlink\" title=\"今日小結\"></a>今日小結</h1><br>\n\n<p><code>cargo --version</code> 驗證版本</p>\n<p><code>cargo new &#123;project_name&#125;</code> 創建專案</p>\n<p><code>cargo build</code> 編譯專案</p>\n<p><code>cargo run</code> 編譯&amp;運行專案</p>\n<p><code>cargo check</code> 驗證專案</p>\n<p><code>cargo build --release</code> 正式版本的編譯</p>\n",
            "tags": [
                "Rust"
            ]
        },
        {
            "id": "https://smilin.net/2023/10/27/rust_learning_01/",
            "url": "https://smilin.net/2023/10/27/rust_learning_01/",
            "title": "Rust 學習紀錄[1] = 日誌中的教學",
            "date_published": "2023-10-27T10:00:00.000Z",
            "content_html": "<p>工欲善其事，必先利其器<br>想學一門語言，要從一篇教學文檔找起</p>\n<p><a href=\"https://doc.rust-lang.org/book/\">官方文檔</a></p>\n<p>恩，官方文檔看起來挺不錯的，就這個吧</p>\n<p>這篇文撰寫當下，文檔對應 Rust 版本為 <code>Rust 1.67.1 (released 2023-02-09) or later</code><br>如果因為版本不同造成閱讀的困擾的話，可以在學會安裝 Rust 後自行降版學習。</p>\n<span id=\"more\"></span>\n\n<br>\n\n<h1 id=\"安裝\"><a href=\"#安裝\" class=\"headerlink\" title=\"安裝\"></a>安裝</h1><br>\n\n<p>說是 Rust，其實第一個遇到的是 <code>rustup</code></p>\n<p><a href=\"https://www.rust-lang.org/tools/install\">Window 安裝 rustup</a></p>\n<p>安裝過程一直 Enter 就好，之後在 cmd 下 <code>rustc --version</code></p>\n<p>得到版本號 <code>rustc 1.73.0 (cc66ad468 2023-10-03)</code>，表示安裝成功</p>\n<p>其他比較常用的指令還有</p>\n<p>更新 Rust 版本 - <code>rustup update</code></p>\n<p>卸載 Rust 跟 rustup - <code>rustup self uninstall</code></p>\n<p>查看 Rust Doc 本機離線版 - <code>rustup doc</code></p>\n<br>\n\n<p>根據 Rust 自己的說明，約莫每兩周會有一次小版更新<br>也因此，除非目標是維護專案，理論上更新版本 &amp; 追蹤文檔改動會很頻繁。</p>\n<br>\n\n<h1 id=\"HELLO-RUST！\"><a href=\"#HELLO-RUST！\" class=\"headerlink\" title=\"HELLO RUST！\"></a>HELLO RUST！</h1><br>\n\n<p>首先讓我們創建一個資料夾</p>\n<p><code>rust_project</code></p>\n<p>往後任何的 Rust 程式都會放在這個資料夾下<br>現在在專案資料夾下新增我們要製作的第一個 Rust 程式</p>\n<p><code>rust_project\\_01_hello_rust\\main.rs</code></p>\n<pre><code>fn main() &#123;\n    println!(&quot;Hello, Rust!&quot;);\n&#125;\n</code></pre>\n<p>之後打開 cmd ，輸入以下</p>\n<pre><code>rustc main.rs\n.\\main.exe // 印出 Hello, Rust!\n</code></pre>\n<p>如此，我們完成了第一隻 Rust 程式。<br><del>超快！！</del><br><del>嘛、畢竟是 Hello World 嘛</del></p>\n<br>\n\n<h1 id=\"感想\"><a href=\"#感想\" class=\"headerlink\" title=\"感想\"></a>感想</h1><br>\n\n<p>首先注意到的，是執行的指令拆成了兩個<br>分別是 <strong>編譯</strong> 的行為與 <strong>執行</strong> 的行為</p>\n<p>編譯出來的檔案是 <code>.exe</code>，意味著寫好的程式不需要借助 Rust 就能運行<br>這在筆者之前的經驗中是比較少見的</p>\n<p>同樣被編譯出來的還有一個 <code>main.pdb</code><br>暫時不知道是做甚麼用的，之後學到再回來更新</p>\n<br>\n\n<p><code>println!();</code><br>在這段酷似 JAVASCRIPT 風格的 JAVA 式命名輸出語法上，突兀的出現了個 <code>!</code></p>\n<p>這是 Rust 的 <code>macro</code><br>比起 Rust 的 <code>function</code>，<code>macro</code> 更接近 JAVASCRIPT 的 <code>function</code></p>\n<p>Rust 中，存在 <code>fn(function)</code> 跟 <code>macro_rules(macro)</code><br>他們的差別主要在於 <code>function(函式)</code> 的參數數量是固定的<br>而 <code>macro(巨集)</code> 則可以動態傳入參數</p>\n<p><code>println</code> 預期要能夠傳入多個參數，當他要做格式化傳輸時</p>\n<pre><code>println!(&quot;Hello, Macro! My name is &#123;&#125;!&quot;, &quot;Smilin&quot;)\n</code></pre>\n<p>比起 <code>fn</code>，<code>macro_rules</code> 顯然更符合需求。</p>\n<br>\n\n<h1 id=\"今日小結\"><a href=\"#今日小結\" class=\"headerlink\" title=\"今日小結\"></a>今日小結</h1><br>\n\n<p><code>rustc --version</code> 驗證版本</p>\n<p><code>rustup update</code> 更新 Rust</p>\n<p><code>rustup self uninstall</code> 反安裝 Rust</p>\n<p><code>rustup doc</code> 運行 Rust Local Doc</p>\n<p><code>rustc main.rs</code> 編譯 rs 檔</p>\n<p><code>.pdb</code> ???</p>\n<p><code>macro</code> 巨集 &#x2F; 宏，可以傳入動態參數</p>\n<p><code>function</code> 函式 &#x2F; 方法，宣告時就要規範好參數數量與型別</p>\n<br>\n\n<h1 id=\"資料參考\"><a href=\"#資料參考\" class=\"headerlink\" title=\"資料參考\"></a>資料參考</h1><br>\n\n<p><a href=\"https://doc.rust-lang.org/book/\">Rust 官方文檔</a></p>\n<p><a href=\"https://www.rust-lang.org/tools/install\">Window 安裝 rustup</a></p>\n",
            "tags": [
                "Rust"
            ]
        },
        {
            "id": "https://smilin.net/2023/10/27/rust_learning_00/",
            "url": "https://smilin.net/2023/10/27/rust_learning_00/",
            "title": "Rust 學習紀錄[0] = 前言",
            "date_published": "2023-10-27T04:00:00.000Z",
            "content_html": "<p><img src=\"https://upload.wikimedia.org/wikipedia/commons/thumb/d/d5/Rust_programming_language_black_logo.svg/216px-Rust_programming_language_black_logo.svg.png\" alt=\"Rust\"></p>\n<br>\n\n<p>2021 年 2 月，Rust 基金會成立</p>\n<p>以 AWS、GOOGLE 等多家資訊巨頭為首<br>因為看好 Rust 兼顧了高效能 &amp; 安全性而投資<br>使得 Rust 這兩年有了巨大的成長。</p>\n<p>這也是為什麼，近幾年工程師無論如何不願意<br>多少也會聽過 Rust 的名號，隱隱有與 C++ 並駕齊驅的勢頭。</p>\n<span id=\"more\"></span>\n\n<p>筆者平常習慣 node.js or java 的開發，接觸 Rust 算是偶然<br>剛好想嘗試所謂能真正實現高效能程式碼(沒碰過 C++)</p>\n<p>做為學習動力，一方面會將自己的學習過程發布在 blog<br>另一方面打算在學到一個階段後，試著用 Rust 構建一個微型社群平台，當作目標。</p>\n<p>本次系列與其說是教學，更像是日記一類的東西，如果能激起看這篇文的你的興趣的話，我會很高興的。</p>\n",
            "tags": [
                "Rust"
            ]
        },
        {
            "id": "https://smilin.net/2023/09/15/deepCopyAndShallowCopy/",
            "url": "https://smilin.net/2023/09/15/deepCopyAndShallowCopy/",
            "title": "淺談 js 深拷貝與淺拷貝的差異",
            "date_published": "2023-09-15T04:00:00.000Z",
            "content_html": "<h1 id=\"Deep-copy-和-Shallow-copy\"><a href=\"#Deep-copy-和-Shallow-copy\" class=\"headerlink\" title=\"Deep copy 和 Shallow copy\"></a>Deep copy 和 Shallow copy</h1><br>\n\n<p>先來個考題：</p>\n<pre><code>a = &#123; foo: &quot;bar&quot; &#125;;\nb = a;\nb.foo = &quot;baz&quot;;\n\nconsole.log(a.foo); // 印出?\n</code></pre>\n<span id=\"more\"></span>\n\n<details>\n<summary>答案</summary>\n<br>\nbaz\n</details>\n\n<p><br><br></p>\n<p>下一題：</p>\n<pre><code>a = &#123; foo: &quot;bar&quot; &#125;;\nb = structuredClone(a); // 深拷貝\nb.foo = &quot;baz&quot;;\n\nconsole.log(a.foo); // 印出?\n</code></pre>\n<details>\n<summary>答案</summary>\n<br>\nbar  \n<br><br>\n深拷貝(Deep Copy) 可以將內層對象一併拷貝  \n</details>\n\n<p><br><br></p>\n<hr>\n<br>\n\n<h2 id=\"Shallow-copy\"><a href=\"#Shallow-copy\" class=\"headerlink\" title=\"Shallow copy\"></a>Shallow copy</h2><br>\n\n<p>淺拷貝(Shallow Copy) 與深拷貝同樣是用來拷貝物件層級，避免指向同一記憶體位置</p>\n<p>與深拷貝不同的是，淺拷貝只會複製第一層的對象，如果是 <code>Object.Object</code> 的結構就沒轍。</p>\n<br>\n\n<h3 id=\"Object-assign\"><a href=\"#Object-assign\" class=\"headerlink\" title=\"Object.assign\"></a>Object.assign</h3><br>\n\n<p><code>Object.assign</code> 屬於淺拷貝(Shallow Copy)<br>在上述案例中，可以得到跟深拷貝一樣的結果</p>\n<pre><code>a = &#123; foo: &#123; fpp: &quot;bar&quot; &#125; &#125;;\nb = Object.assign(&#123;&#125;, a);\nb.foo.fpp = &quot;baz&quot;;\n\nconsole.log(a.foo.fpp); // 印出baz\n</code></pre>\n<br>\n\n<h3 id=\"解構賦值\"><a href=\"#解構賦值\" class=\"headerlink\" title=\"解構賦值\"></a>解構賦值</h3><br>\n\n<p>解構賦值是 <code>ES6</code> 以後的語法糖，同樣屬於淺拷貝</p>\n<pre><code>const a = &#123; b: 1 &#125;;\nconst c = &#123; ...a &#125;; // 解構賦值\nc.b = 2;\nconsole.log(a); // &#123; b: 1 &#125;\n</code></pre>\n<p>得益於其精簡的代碼，實務上很常使用。</p>\n<p><br><br></p>\n<hr>\n<br>\n\n<h2 id=\"Deep-copy\"><a href=\"#Deep-copy\" class=\"headerlink\" title=\"Deep copy\"></a>Deep copy</h2><br>\n\n<p>與前面提到的淺拷貝不同，深拷貝對於深層結構也能一併複製</p>\n<br>\n\n<h3 id=\"早期的深拷貝\"><a href=\"#早期的深拷貝\" class=\"headerlink\" title=\"早期的深拷貝\"></a>早期的深拷貝</h3><pre><code>JSON.parse(JSON.stringify());\n</code></pre>\n<p>這個寫法大致上有以下缺點：</p>\n<ul>\n<li>忽略 <code>function</code></li>\n<li>忽略原形鏈</li>\n<li>忽略 <code>undefined</code></li>\n<li>子層太多會導致 <code>stack overflow</code></li>\n</ul>\n<p>儘管如此，由於已經可以處理大多狀況<br>如果不是為了性能或是特殊邏輯，此寫法已經夠用，是常見的深拷貝實現。</p>\n<br>\n\n<h3 id=\"structuredClone\"><a href=\"#structuredClone\" class=\"headerlink\" title=\"structuredClone\"></a>structuredClone</h3><p><code>structuredClone</code> 是 <code>node.js</code> 17 版以後支援的官方深拷貝實現</p>\n<p>目前各大瀏覽器默認支援此語法</p>\n<p><img src=\"https://i.imgur.com/tPXjO1o.png\" alt=\"1\"></p>\n<br>\n\n<p><code>structuredClone</code> 存在一些限制</p>\n<p>不允許結構中存在 <code>Error</code> 、 <code>Function</code> 以及 <code>DOM</code> 對象</p>\n<p>不保留 <code>RegExp</code> 對象的 <code>lastIndex</code></p>\n<p>不保留 <code>read-only</code> 等描述符，即無法限制 <code>setters</code> <code>getters</code></p>\n<p>不保留原形鏈</p>\n",
            "tags": [
                "javascript"
            ]
        },
        {
            "id": "https://smilin.net/2023/09/11/alist-file-error/",
            "url": "https://smilin.net/2023/09/11/alist-file-error/",
            "title": "Alist 單檔太大上傳失敗，思路整理",
            "date_published": "2023-09-11T10:00:00.000Z",
            "content_html": "<p><strong>註：本文並沒有完全解決遇到的上傳問題</strong><br><strong>筆者只想到替代方案，曲線救國</strong></p>\n<br>\n\n<p>筆者是自建雲端的愛用者，目前使用 Alist</p>\n<p>前一陣子因為自身需求，添加了 Cloudflare 反向代理</p>\n<p>原本一切看起來都很美好，但某天上傳檔案時才發現不對，只要檔案大於 100 MB 就有機會遇到 413 問題。</p>\n<p><img src=\"https://i.imgur.com/rNNhTq5.png\" alt=\"1\"></p>\n<p><a href=\"https://alist.nn.ci/zh/guide/install/reverse-proxy.html\">官方的反向代理配置</a></p>\n<p>可以看到，文檔下大多也是哀鴻遍野，看來只要配置了反代很容易就會碰到這個問題</p>\n<p>尤其文檔不支援 Cloudflare，實在頭痛..</p>\n<span id=\"more\"></span>\n\n<h1 id=\"問題排查\"><a href=\"#問題排查\" class=\"headerlink\" title=\"問題排查\"></a>問題排查</h1><h2 id=\"NGINX-設定-client-max-body-size\"><a href=\"#NGINX-設定-client-max-body-size\" class=\"headerlink\" title=\"NGINX 設定 client_max_body_size\"></a>NGINX 設定 client_max_body_size</h2><p>參考資料時，大多資料都指向是 NGINX 設定的問題<br>只要將 <code>client_max_body_size</code> 上限拉高即可解決</p>\n<pre><code>server &#123;\n    ．．．．．．．．．\n    location / &#123;\n    ．．．．\n        client_max_body_size 10G;\n    ．．．．\n    &#125;\n    ．．．．．．．．．\n&#125;\n</code></pre>\n<p>不過筆者並沒有使用到 NGINX，此解顯然並非這次遇到的問題</p>\n<br>\n\n<h2 id=\"Cloudflare-緩存問題\"><a href=\"#Cloudflare-緩存問題\" class=\"headerlink\" title=\"Cloudflare 緩存問題\"></a>Cloudflare 緩存問題</h2><p>爬文發現有人提到可能是 Cloudflare 緩存的問題</p>\n<p>在 Rule -&gt; Page Rules -&gt; Create Page Rule</p>\n<p><img src=\"https://i.imgur.com/N8gi01N.png\" alt=\"2\"></p>\n<p>之後再到 Caching -&gt; Cache Rules -&gt; Create rule</p>\n<p><img src=\"https://i.imgur.com/TAkvVl3.png\" alt=\"3\"></p>\n<p>設定完後再上傳，成功迴避掉 413 問題!</p>\n<br>\n\n<h1 id=\"新的問題\"><a href=\"#新的問題\" class=\"headerlink\" title=\"新的問題\"></a>新的問題</h1><p>甜美的日子沒過多久<br>雖然照著上述配置後，不會再出現 413 了，但..</p>\n<p><img src=\"https://i.imgur.com/hHjLAns.png\" alt=\"4\"></p>\n<p>馬上就遇到新的錯誤了 QQ…</p>\n<p>這個問題問 google 大神也沒甚麼好辦法<br>沒辦法囉，只好再次自己動手檢查</p>\n<h2 id=\"測試過程\"><a href=\"#測試過程\" class=\"headerlink\" title=\"測試過程\"></a>測試過程</h2><p>Error Log 只寫了網路問題，偶而會提示</p>\n<pre><code>&#123;&quot;message&quot;:&quot;A listener indicated an asynchronous response by returning true, but the message channel closed before a response was received&quot;&#125;\n</code></pre>\n<p>猜測是 Cloudflare 提早關閉了連線</p>\n<p>有趣的是只要同時下載檔案，上傳不會失敗</p>\n<p>開啟 Cloudflare Development Mode ，上傳失敗</p>\n<h2 id=\"Cloudflare-免費版限制\"><a href=\"#Cloudflare-免費版限制\" class=\"headerlink\" title=\"Cloudflare 免費版限制\"></a>Cloudflare 免費版限制</h2><p><img src=\"https://i.imgur.com/lm8M9jc.png\" alt=\"5\"></p>\n<p>Cloudflare 免費版用戶上傳檔案時，有著 100MB 的上限</p>\n<p>Alist 僅支援單檔上傳<br><a href=\"https://github.com/alist-org/alist/issues/5176\">github issue</a></p>\n<p>想來或許就是在這關上卡住了</p>\n<p>如開發者所說， Alist 的上傳存在一定的缺陷</p>\n<p>就算不使用 Cloudflare，直連上傳過大的檔案也有機會失敗</p>\n<p>好在除此之外功能正常，頂多不透過網頁，自行額外實現上傳方法即可(Ex:webdav&#x2F;ftp&#x2F;nasGui&#x2F;local..)</p>\n<br>\n\n<hr>\n<p>文章參考:<br><a href=\"https://lanwp.org/12-cloudreve-nextcloud-alist-and-cloudflare_cdn/\">https://lanwp.org/12-cloudreve-nextcloud-alist-and-cloudflare_cdn/</a></p>\n",
            "tags": [
                "Alist",
                "Cloudflare"
            ]
        },
        {
            "id": "https://smilin.net/2023/09/06/alist-started/",
            "url": "https://smilin.net/2023/09/06/alist-started/",
            "title": "Alist 好用的自建雲端分享",
            "date_published": "2023-09-06T02:00:00.000Z",
            "content_html": "<p>隨著 GOOGLE &#x2F; ONEDRIVE 等空間限制增多</p>\n<p>筆者轉為使用自架雲端方案一段時間，其中特別中意 Alist 的畫面</p>\n<p><img src=\"https://i.imgur.com/cwZF7fX.png\" alt=\"1\"></p>\n<p>高自定義的 UI，強大的用戶管理<br>最重要的是在目錄下默認讀取 readme.md 做介紹！</p>\n<p>整理雲端檔案，最常遇到的難題<br>就是多年後很難輕易在一堆檔案中找到自己需要的資料</p>\n<p>除此以外還支援</p>\n<ul>\n<li>元數據(載入特定目錄會跳出的訊息)</li>\n<li>文件搜索</li>\n<li>雲端掛載(GD&#x2F;OD&#x2F;MEGA&#x2F;還有一堆..)</li>\n</ul>\n<p>使用 Alist 不僅能讓雲端變得美觀，還能很輕鬆的管理文件</p>\n<span id=\"more\"></span>\n\n<h2 id=\"Alist-官方文檔\"><a href=\"#Alist-官方文檔\" class=\"headerlink\" title=\"Alist 官方文檔\"></a><a href=\"https://alist.nn.ci/zh/\">Alist 官方文檔</a></h2><p><img src=\"https://i.imgur.com/pbxhpkZ.png\" alt=\"2\"></p>\n<p>從文檔首頁可以感受到，Alist 有著強大的功能</p>\n<p>因為支援中文，在閱讀文檔時不會遇到障礙</p>\n<h2 id=\"環境建置\"><a href=\"#環境建置\" class=\"headerlink\" title=\"環境建置\"></a>環境建置</h2><p>筆者使用 Docker 運行 Alist</p>\n<pre><code>docker pull xhofe/alist:v3.13.2\n\ndocker run -d --restart=always -v &#123;你的本機目錄&#125;:/opt/alist/data -p 5244:5244 -e PUID=0 -e PGID=0 -e UMASK=022 --name=&quot;alist&quot; xhofe/alist:v3.13.2\n</code></pre>\n<p>記得將上方的 {你的本機目錄} 替換成你的環境</p>\n<p>Container run 起後使用這段指令查看預設帳號密碼</p>\n<pre><code>docker exec -it alist ./alist admin\n</code></pre>\n<p><img src=\"https://i.imgur.com/sKMQUPf.png\" alt=\"3\"></p>\n<p><img src=\"https://i.imgur.com/wvAH9Od.png\" alt=\"4\"></p>\n<p>登入成功後我們會回到首頁，這裡目前甚麼都沒有</p>\n<p>在網址後方加入 @manage 進入控制台</p>\n<p><img src=\"https://i.imgur.com/8ziYJ8B.png\" alt=\"5\"></p>\n<p>這邊先將管理員帳密改成你好記的樣子</p>\n<p>在存儲可以添加需要加入到 Alist 的空間<br>從基本的本地環境到雲端都可以放在 Alist 管理</p>\n<p>設置雲端掛載時記得根據 Alist 版本，查看對應的文檔，留意任何留言，記得備份~</p>\n<p>筆者這邊以本地環境做示範</p>\n<br>\n\n<hr>\n<br>\n\n<p>首先到設定 {你的本機目錄} 的地方，創建一個資料夾</p>\n<p>這會做為未來我們掛載本地檔案的路徑</p>\n<p><img src=\"https://i.imgur.com/FKzeLks.png\" alt=\"6\"></p>\n<ul>\n<li>驅動選擇 本地存儲</li>\n<li>掛載路徑 &#x2F;{資料夾名稱}</li>\n<li>根資料夾路徑 &#x2F;opt&#x2F;alist&#x2F;data&#x2F;{資料夾名稱}</li>\n</ul>\n<p><img src=\"https://i.imgur.com/oCqbTCR.png\" alt=\"7\"><br><img src=\"https://i.imgur.com/mOr53lK.png\" alt=\"8\"></p>\n<p>設定完大致如上</p>\n<br>\n\n<p><img src=\"https://i.imgur.com/ZimHdEW.png\" alt=\"9\"></p>\n<p>回首頁看就會有空間了!</p>\n<br>\n\n<h2 id=\"實用-CSS\"><a href=\"#實用-CSS\" class=\"headerlink\" title=\"實用 CSS\"></a>實用 CSS</h2><p>Alist 後台的 “設置” ，可以調整絕大多數的 UI 畫面<br>不過如果想自定義一些細節，推薦使用 CSS 達成</p>\n<p>設置 -&gt; 全域設定 -&gt; 自定義頭部</p>\n<p>可以在這做自定義 CSS 的添加<br>以下提供一些不錯的樣式</p>\n<br>\n\n<h3 id=\"去除網站圖標與搜索\"><a href=\"#去除網站圖標與搜索\" class=\"headerlink\" title=\"去除網站圖標與搜索\"></a>去除網站圖標與搜索</h3><pre><code>&lt;style&gt;.hope-stack.hope-c-dhzjXW.hope-c-PJLV.hope-c-PJLV-iiOacaA-css &#123;display: none!important;&#125;&lt;/style&gt;\n</code></pre>\n<h3 id=\"站點公告去除-X-關閉按鈕\"><a href=\"#站點公告去除-X-關閉按鈕\" class=\"headerlink\" title=\"站點公告去除 X 關閉按鈕\"></a>站點公告去除 X 關閉按鈕</h3><pre><code>&lt;style&gt;.notify-render .hope-close-button&#123;display: none;&#125;&lt;/style&gt;\n</code></pre>\n<h3 id=\"使用背景圖-亮色背景-GIF-可用\"><a href=\"#使用背景圖-亮色背景-GIF-可用\" class=\"headerlink\" title=\"使用背景圖(亮色背景)(GIF 可用)\"></a>使用背景圖(亮色背景)(GIF 可用)</h3><pre><code>&lt;style&gt;.hope-ui-light&#123;background-image: url(&quot;&quot;)!important;background-repeat:no-repeat;background-size:cover;background-attachment:fixed;background-position-x:center;&#125;&lt;/style&gt;\n</code></pre>\n<h3 id=\"使用背景圖-暗色背景-GIF-可用\"><a href=\"#使用背景圖-暗色背景-GIF-可用\" class=\"headerlink\" title=\"使用背景圖(暗色背景)(GIF 可用)\"></a>使用背景圖(暗色背景)(GIF 可用)</h3><pre><code>&lt;style&gt;.hope-ui-dark &#123;background-image: url(&quot;&quot;) !important;background-repeat:no-repeat;background-size:cover;background-attachment:fixed;background-position-x:center;&#125;&lt;/style&gt;\n</code></pre>\n<h3 id=\"列表改透明-亮色背景\"><a href=\"#列表改透明-亮色背景\" class=\"headerlink\" title=\"列表改透明(亮色背景)\"></a>列表改透明(亮色背景)</h3><pre><code>&lt;style&gt;.obj-box.hope-stack.hope-c-dhzjXW.hope-c-PJLV.hope-c-PJLV-igScBhH-css&#123;background-color: rgba(255, 255, 255, 0.5) !important;&#125;&lt;/style&gt;\n</code></pre>\n<h3 id=\"列表改透明-暗色背景\"><a href=\"#列表改透明-暗色背景\" class=\"headerlink\" title=\"列表改透明(暗色背景)\"></a>列表改透明(暗色背景)</h3><pre><code>&lt;style&gt;.obj-box.hope-stack.hope-c-dhzjXW.hope-c-PJLV.hope-c-PJLV-iigjoxS-css&#123;background-color:rgb(0 0 0 / 50%) !important;&#125;&lt;/style&gt;\n</code></pre>\n<h3 id=\"元信息改透明-亮色背景\"><a href=\"#元信息改透明-亮色背景\" class=\"headerlink\" title=\"元信息改透明(亮色背景)\"></a>元信息改透明(亮色背景)</h3><pre><code>&lt;style&gt;.hope-c-PJLV.hope-c-PJLV-ikSuVsl-css&#123;background-color: rgba(255, 255, 255, 0.5)!important;&#125;&lt;/style&gt;\n</code></pre>\n<h3 id=\"元信息改透明-暗色背景\"><a href=\"#元信息改透明-暗色背景\" class=\"headerlink\" title=\"元信息改透明(暗色背景)\"></a>元信息改透明(暗色背景)</h3><pre><code>&lt;style&gt;.hope-c-PJLV.hope-c-PJLV-iiuDLME-css&#123;background-color:rgb(0 0 0 / 50%)!important;&#125;&lt;/style&gt;\n</code></pre>\n<h3 id=\"去除尾頁\"><a href=\"#去除尾頁\" class=\"headerlink\" title=\"去除尾頁\"></a>去除尾頁</h3><pre><code>&lt;style&gt;.footer &#123;display: none !important;&#125;]&lt;/style&gt;\n</code></pre>\n<h3 id=\"移除下載選項\"><a href=\"#移除下載選項\" class=\"headerlink\" title=\"移除下載選項\"></a>移除下載選項</h3><pre><code>&lt;style&gt;.hope-select__trigger.hope-c-kvTTWD.hope-c-huZphZ.hope-c-kvTTWD-hYRNAb-variant-filled.hope-c-kvTTWD-gfwxhr-size-md.hope-c-huZphZ-cIGthf-cv.hope-c-PJLV.hope-c-PJLV-ijSQbqe-css&#123;display: none !important;&#125;&lt;/style&gt;\n</code></pre>\n<br>\n\n<p>推薦一些網站:<br><a href=\"https://anwen-anyi.github.io/\">Alist 魔改代碼分享</a><br><a href=\"https://telegra.ph/AList-UI-01-11\">CSS 參考</a></p>\n",
            "tags": [
                "Alist"
            ]
        },
        {
            "id": "https://smilin.net/2023/06/01/discordJs14-1/",
            "url": "https://smilin.net/2023/06/01/discordJs14-1/",
            "title": "discord.js 升上 14 版，架構說明",
            "date_published": "2023-06-01T12:00:00.000Z",
            "content_html": "<p><a href=\"https://github.com/Mr-Smilin/AliceZero/tree/v14\">github 連結</a></p>\n<p>從 2021 年，discord.js 升上 13 版<br>heroku 改成收費<br>youtube 不喜歡 discord 蹭他們的服務<br>音樂機器人相繼關閉 yt 服務<br>12 版許多功能時常報錯<br>discord.js 升上 14 版..</p>\n<br>\n\n<p>期間不管是工作又或是休假時，都很希望能升級以前寫的機器人<br>不斷想重構出更好維護的程式架構，也一再推翻之前的程式</p>\n<br>\n\n<p>終於..！在最近 Alice 也正式升上了 discord.js 14.11.0 版本<br>不會總是因為舊版本不支援而爆炸啦！(誤)</p>\n<p><img src=\"https://i.imgur.com/M6hj8wU.jpg\" alt=\"levelUp!\"></p>\n<span id=\"more\"></span>\n\n<br>\n\n<hr>\n<br>\n\n<h2 id=\"安裝套件\"><a href=\"#安裝套件\" class=\"headerlink\" title=\"安裝套件\"></a>安裝套件</h2><p>必備</p>\n<ul>\n<li>Node.js v16.9.0 或以上</li>\n<li>Discord.js v14.11.0<br>discord.js 核心套件<pre><code>npm install discord.js@14.11.0\n</code></pre>\n</li>\n<li>dotenv v16.0.3<br>讀取 .env ，即 token 的套件<pre><code>npm install dotenv@16.0.3\n</code></pre>\n</li>\n</ul>\n<details>\n<summary>點我展開BDB(baseDiscordBot.js)所需套件</summary>\n\n<br>\n\n<ul>\n<li>@discordjs&#x2F;builders v1.3.0<br>discord.js 提供的類別產生器類型<pre><code>npm install @discordjs/builders@1.3.0\n</code></pre>\n</li>\n</ul>\n</details>\n\n<br>\n\n<details>\n<summary>點我展開音樂系統所需套件</summary>\n\n<br>\n\n<ul>\n<li>@discordjs&#x2F;voice v0.16.0<br>控制 discord 語音的核心套件<br>p.s.使用舊版本極度容易出現問題，如果播放過程發生 bug 可以先檢查 voice 是不是最新版<pre><code>npm install @discordjs/voice@0.16.0\n</code></pre>\n</li>\n<li>@discordjs&#x2F;opus v0.9.0<br>Opus 編碼器<pre><code>npm install @discordjs/opus@0.9.0\n</code></pre>\n</li>\n<li>ffmpeg-static v5.1.0<br>ffmpeg 轉碼器<pre><code>npm install ffmpeg-static@5.1.0\n</code></pre>\n</li>\n<li>libsodium-wrappers v0.7.11<br>串流加密工具<pre><code>npm install libsodium-wrappers@0.7.11\n</code></pre>\n</li>\n<li>play-dl v1.9.6<br> 串流套件，取代 ytdl-core<pre><code>npm install play-dl@1.9.6\n</code></pre>\n</li>\n</ul>\n</details>\n\n<br>\n\n<details>\n<summary>點我展開Render託管推薦套件</summary>\n\n<br>\n\n<ul>\n<li>axios v1.4.0<br>打 http 使用的套件<pre><code>npm install axios@1.4.0\n</code></pre>\n</li>\n<li>node-schedule v2.1.0<br>定時任務套件<pre><code>npm node-schedule@2.1.0\n</code></pre>\n</li>\n</ul>\n</details>\n\n<br>\n\n<hr>\n<br>\n\n<h2 id=\"前置動作\"><a href=\"#前置動作\" class=\"headerlink\" title=\"前置動作\"></a>前置動作</h2><p>如果是舊版 discord bot ，要先去 <a href=\"https://discord.com/developers/applications\">discordDeveloper</a><br>選中自己的 bot 後，選擇左邊 Bot 選項，然後將這邊的開關都打開</p>\n<p><img src=\"https://i.imgur.com/GoIc5Ld.png\" alt=\"2\"></p>\n<p>這是一些限制機器人存取特定資訊的開關，默認是關閉的，如果沒有打開，就算在程式中要求存取權，也是拿不到這些資訊的喔！</p>\n<p>之後在專案根目錄創建一個 <code>.env</code> 檔案，性質類似於以前教學中的 <code>auth.json</code><br>差別在於，放在 <code>Environment</code> 的參數意味著參數不該被公開，不會在任何的公開場合獲得此類 value (例如 github)，僅在執行專案時會被注入</p>\n<h3 id=\"env-預覽\"><a href=\"#env-預覽\" class=\"headerlink\" title=\".env 預覽\"></a>.env 預覽</h3><pre><code>TOKEN=&quot;your bot token&quot;\nMASTER_ID=&quot;your client ID&quot;\n</code></pre>\n<h2 id=\"專案結構\"><a href=\"#專案結構\" class=\"headerlink\" title=\"專案結構\"></a>專案結構</h2><br>\n\n<details>\n<summary>點我展開專案結構</summary>\n\n<p>AliceZero&#x2F;<br>├─ baseJS&#x2F;<br>│ 　　 ├ BaseDiscordBot.js<br>│ 　　 ├ CatchF.js<br>│ 　　 ├ CronTask.js<br>│ 　　 ├ HealthCheck.js<br>├─ manager&#x2F;<br>│ 　　 ├ buttonManager&#x2F;<br>│ 　　 ├ 　　 ├ commands&#x2F;<br>│ 　　 ├ 　　 ├ 　　 ├ helpNowQueue.js<br>│ 　　 ├ 　　 ├ 　　 ├ helpPause.js<br>│ 　　 ├ 　　 ├ 　　 ├ helpPlay.js<br>│ 　　 ├ 　　 ├ 　　 ├ helpPlayFirst.js<br>│ 　　 ├ 　　 ├ 　　 ├ helpResume.js<br>│ 　　 ├ 　　 ├ 　　 ├ helpSkip.js<br>│ 　　 ├ 　　 ├ 　　 ├ helpSleep.js<br>│ 　　 ├ 　　 ├ 　　 ├ helpTrpgDice.js<br>│ 　　 ├ 　　 ├ 　　 ├ helpTrpgSort.js<br>│ 　　 ├ 　　 ├ 　　 ├ myKiritoSkillNicename.js<br>│ 　　 ├ 　　 ├ 　　 ├ myKiritoSkillSkill.js<br>│ 　　 ├ 　　 ├ 　　 ├ myKiritoSkillStatus.js<br>│ 　　 ├ 　　 ├ buttonC.js<br>│ 　　 ├ 　　 ├ buttonM.js<br>│ 　　 ├ 　　 ├ buttonType.json<br>│ 　　 ├ componentManager&#x2F;<br>│ 　　 ├ 　　 ├ componentM.js<br>│ 　　 ├ embedManager&#x2F;<br>│ 　　 ├ 　　 ├ embedC.js<br>│ 　　 ├ messageManager&#x2F;<br>│ 　　 ├ 　　 ├ messageC.js<br>│ 　　 ├ 　　 ├ messageM.js<br>│ 　　 ├ 　　 ├ messagePrefix.json<br>│ 　　 ├ 　　 ├ messageUpdateM.js<br>│ 　　 ├ 　　 ├ nineData.js<br>│ 　　 ├ musicManager&#x2F;<br>│ 　　 ├ 　　 ├ musicC.js<br>│ 　　 ├ 　　 ├ musicM.js<br>│ 　　 ├ mykiritoManager&#x2F;<br>│ 　　 ├ 　　 ├ requests&#x2F;<br>│ 　　 ├ 　　 ├ 　　 ├ boss.js<br>│ 　　 ├ 　　 ├ 　　 ├ level.js<br>│ 　　 ├ 　　 ├ 　　 ├ skill.js<br>│ 　　 ├ 　　 ├ myKiritoC.js<br>│ 　　 ├ 　　 ├ myKiritoM.js<br>│ 　　 ├ selectMenuManager&#x2F;<br>│ 　　 ├ 　　 ├ commands&#x2F;<br>│ 　　 ├ 　　 ├ 　　 ├ help.js<br>│ 　　 ├ 　　 ├ selectMenuC.js<br>│ 　　 ├ 　　 ├ selectMenuM.js<br>│ 　　 ├ slashManager&#x2F;<br>│ 　　 ├ 　　 ├ commands&#x2F;<br>│ 　　 ├ 　　 ├ 　　 ├ help.js<br>│ 　　 ├ 　　 ├ 　　 ├ m.js<br>│ 　　 ├ 　　 ├ slashM.js<br>│ 　　 ├ trpgManager&#x2F;<br>│ 　　 ├ 　　 ├ trpgC.js<br>│ 　　 ├ 　　 ├ trpgM.js<br>├─ .env<br>├─ alice.js<br>├─ package.json<br>├─ package-lock.json</p>\n</details>\n\n<br>\n\n<p>因為這篇不是教學，不會一個個講解，大概說明一下各 Manager 的作用</p>\n<ul>\n<li>BaseDiscordBot.js<br>從登入 token 到訊息傳送<br>與 discord.js 的任何交互都在這，唯一引用 discord.js 的地方<br>好處是當 discord.js 改版時只要更改 BDB 即可<br>壞處是其他地方的邏輯可能會比較難以理解，都需要點進 BDB 查看</li>\n<li>CatchF.js<br>自定義的 log 工具，改這裡就可以一次更改所有的 log style</li>\n<li>CronTask.js<br>託管平台用到的工具</li>\n<li>HealthCheck.js<br>同上</li>\n<li>alice.js<br><code>npm start</code> 的執行檔，敘述了啟動時會執行的內容</li>\n<li>slashManager<br>discord.js 13 版以後新增的斜線指令，包含其註冊與監聽的方法都寫在這<br>commands 可以看出這個 bot 目前有多少指令(本次範例來說有 <code>help</code> 跟 <code>m</code> 指令)</li>\n<li>messageManager<br>傳統 bot 對文字訊息回應的主要行為，<code>messageUpdate</code> 訊息更新觸發的行為也放在這</li>\n<li>selectMenuManager<br>菜單組件，commands 可以看出這個 bot 目前有多少菜單組件</li>\n<li>buttonManager<br>按鈕組件，commands 可以看出這個 bot 目前有多少按鈕組件</li>\n<li>embedManager<br>嵌入式訊息組件，<code>@discordjs/builders</code> 有著 <code>EmbedBuilder</code> 這個 embed 產生器<br>避免往後的更新要改一堆地方，在 BDB 中被繼承完才給 embedManager 使用</li>\n<li>componentManager<br>組件管理器，當訊息非單純的文字訊息，有使用到 菜單 &#x2F; 按鈕 &#x2F; 嵌入訊息 任一組件時，會從這裡拿</li>\n<li>musicManager<br>音樂相關邏輯，musicM 負責定義邏輯，musicC 實例實際內容，與 <code>play-dl</code> 等套件互動</li>\n<li>trpgManager<br>派對系統，目前只會骰骰子，而且 code 還是從舊版直接搬過來的..</li>\n<li>mykiritoManager<br>攻略組系統，提供 mykirito 大群的資訊查詢，雖然很久沒更新，但仍然還有人在使用，所以也更新過來了。</li>\n</ul>\n<p><a href=\"https://github.com/Mr-Smilin/AliceZero/tree/v14\">github 連結</a></p>\n<br>\n\n<p>現在的架構算是終於確定下來，以後會在這個架構上繼續更新<br>不過畢竟是 side project ，架構中有些地方整理的比較草率<br>如果之後寫教學，會重新寫一個 bot 的</p>\n<p>看到這裡的朋友，如果在寫 bot ，但苦於不知該如何下手的話<br>這裡推薦可以看看 <a href=\"https://b-l-u-e-b-e-r-r-y.github.io/post/DiscordBot03/\">藍莓大大</a> 的文章<br>淺顯以懂，最後甚至是給了乾貨，可以直接載了拿去用~</p>\n<p>或是使用 <a href=\"https://github.com/Mr-Smilin/BaseDiscordBot\">我的 BDB</a><br>除了像是 mykirito 這種比較偏門的功能，其他 alice 會的指令都會慢慢更新在 BDB 專案上，可以自由取用~</p>\n<p>感謝看到這裡的你^^!</p>\n",
            "tags": [
                "node.js",
                "bot",
                "discord",
                "discord.js"
            ]
        },
        {
            "id": "https://smilin.net/2022/10/25/herokuToRender/",
            "url": "https://smilin.net/2022/10/25/herokuToRender/",
            "title": "將專案從heroku轉到render過程思路",
            "date_published": "2022-10-25T10:00:00.000Z",
            "content_html": "<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>大家好，我是微笑</p>\n<p>繼上次發文過了九個月了</p>\n<p>很可怕啊，感覺自己好混，哈哈哈</p>\n<p>疫情期間，遇到了不少事情，最近才終於有一點調整回正軌的感覺</p>\n<p>剛好 Heroku 發生了一些問題，需要搬移程序到其他託管平台，這邊順便 <del>水一點文章</del></p>\n<br>\n\n<span id=\"more\"></span>\n\n<hr>\n<h3 id=\"關於發生在-Heroku-上的一些問題\"><a href=\"#關於發生在-Heroku-上的一些問題\" class=\"headerlink\" title=\"關於發生在 Heroku 上的一些問題\"></a>關於發生在 Heroku 上的一些問題</h3><p>Heroku 在10月初時，寄送給了開發者一封信</p>\n<p>裡面提到，Heroku 將於2022年11月28號以後，全面關閉免費方案的主機</p>\n<p>如果繼續使用 Heroku 的話，根據目前定價方案，一台託管主機需要負擔一個月 7 美元的成本</p>\n<p>對於單純在學習的學生，又或是我這種程序用愛發電沒有利益的行為，顯然是十足的噩耗</p>\n<p>也因此，原本在 Heroku 上使用免費方案的使用者，開始到處尋找可以繼續使用的平台。</p>\n<p><img src=\"https://i.imgur.com/K3Pngg8.png\" alt=\"heroku將於2022年11月28號以後，全面關閉免費方案的主機\"></p>\n<br>\n\n<hr>\n<h3 id=\"多樣化的選擇\"><a href=\"#多樣化的選擇\" class=\"headerlink\" title=\"多樣化的選擇\"></a>多樣化的選擇</h3><p>因應 Heroku 收費化的開始，有許多平台陸續浮現到開發者的眼前，其中甚至有網站的標題是「Migrate from Heroku to Railway」</p>\n<p>可以看到，除了 Heroku 以外仍有許多平台等待著開發者發掘(Fly.io&#x2F;Railway.app&#x2F;GoogleCloudPlatform - CloudRun等..)</p>\n<p>雖然根據專案不同，沒有所謂最好的選擇，不過筆者在多次嘗試後，最後決定將程式搬遷到 Render 上</p>\n<br>\n\n<hr>\n<h3 id=\"render-com\"><a href=\"#render-com\" class=\"headerlink\" title=\"render.com\"></a>render.com</h3><p><img src=\"https://i.imgur.com/JqcraLM.png\" alt=\"render.com\"></p>\n<br>\n\n<p>當初搬遷主機時，最看中的點就是希望能盡量不用改動原本的架構，免費額度足夠</p>\n<p>Render 目前有著每月 750 小時的免費額度，只開一台機器的話等同免費</p>\n<p>並且他支援從 GitHub &#x2F; GitLab 等開源平台專案部署的方式，功能單一讓流程簡化</p>\n<p>除了支援許多語言直接部署，也支援 Docker 映像檔部署，這幾乎是現在主流平台都有的功能了。</p>\n<p>那因為筆者的專案使用 Node.js，剛好在 Render 支援的語言列表內，所以設定好之後，將專案推到 Github，他就會自動做部署行為了</p>\n<br>\n\n<hr>\n<h3 id=\"部署流程\"><a href=\"#部署流程\" class=\"headerlink\" title=\"部署流程\"></a>部署流程</h3><br>\n\n<p>第一次部署肯定會比較麻煩的</p>\n<p>首先我們要先用 Github 帳號登入 Render 註冊帳號，進來後他會先告訴你，免費方案如以下</p>\n<p><img src=\"https://i.imgur.com/TFqJqEB.png\" alt=\"免費方案\"></p>\n<br>\n\n<p>Render 提供許多方案，這邊我們要找到 web services 才能使用免費主機</p>\n<br>\n\n<p><img src=\"https://i.imgur.com/JgEO1dE.png\" alt=\"Overview\"></p>\n<br>\n\n<p>之後取得 Github 授權 repository，就可以載入專案，選擇主機地區，語言等設置</p>\n<p>比較需要注意的是，因為 Render 的 web 每個半小時無人訪問，會進入休眠(記得 Heroku 也有這類設定)</p>\n<p>需要再次訪問網站才能讓他喚醒</p>\n<p>以 Node 來說，我們可以使用 request 跟 node-schedule ，呼叫自己防止進入睡眠的方式，來讓真正需要的程序能不間斷運行</p>\n<br>\n\n<hr>\n<h3 id=\"env\"><a href=\"#env\" class=\"headerlink\" title=\"env\"></a>env</h3><br>\n\n<p>以前在 Heroku ，如果不透過 Github 自動部署，而是用 Heroku Git 的話，是可以直接將較為私密的 key 等資料，直接明碼上傳上去的</p>\n<p>雖然不是很好的做法，但是對於私人專案來說，這的確是個很方便的做法，只上傳在 Heroku 也有效的保障了程序的安全性</p>\n<p>但是 Render 只接受 Github 鏡像部署，私密的 key 是無論如何都不會放在 Github 上的</p>\n<p>Render 在 env 的設定上也是十分方便，<a href=\"https://render.com/docs/configure-environment-variables\">官方流程可參考這篇文檔</a></p>\n<p><img src=\"https://i.imgur.com/dvzYkqs.png\" alt=\"env\"></p>\n<br>\n\n<p>單一的 key 要放在 Environment Variables</p>\n<p>如果原本就習慣使用 .env 管理所有參數的話，可以將檔案的內容複製進 Secret Files</p>\n<p>Render 在 env 有個好處是，一般平台設置 env 後，基於安全性，平台都不會讓使用者在前台存取 env 的真實資料</p>\n<p>但是 Render 可以，而且還可以直接修改內容，雖然必須犧牲一些安全性，但這樣也方便了開發者對值的管理，對筆者來說是利大於弊</p>\n<br>\n\n<hr>\n<h3 id=\"結語\"><a href=\"#結語\" class=\"headerlink\" title=\"結語\"></a>結語</h3><br>\n\n<p>筆者當初使用 Heroku，是因為接觸了 discord bot，為此還寫了鐵人賽</p>\n<p>說長不長說短不短的兩年，Heroku 宣告收費化，對於筆者這樣的使用者來說，就像是一個平台的關閉一般</p>\n<p>這兩年從後端摸到前端，再從前端學回後端，因為疫情也遇到了不少事情，原本覺得搬遷主機，對於筆者這點能力來說一定是一件艱鉅的工程</p>\n<p>不過在搬遷的過程中，重新拾起 Node，摸索對筆者最好的平台時，感受到許多愉快，有一種 原來我還是能快樂寫 code 阿，的感想</p>\n<p>我想 sideProject 就像是開發者們心靈的綠洲吧，能因為這次機會，重新澆灌他，我也收穫頗豐。</p>\n<p><a href=\"https://ithelp.ithome.com.tw/articles/10255630\">文末附上去年內部員工自己寫的推薦文</a></p>\n",
            "tags": [
                "node.js",
                "bot",
                "discord",
                "discord.js",
                "教學",
                "heroku",
                "render",
                "render.com"
            ]
        }
    ]
}