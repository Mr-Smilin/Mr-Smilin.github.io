{
    "version": "https://jsonfeed.org/version/1",
    "title": "微笑工房 • All posts by \"程式相關\" category",
    "description": "程式教學 C#/JAVA/HTML5/NODE.JS，後端開發，日常瑣記",
    "home_page_url": "https://smilin.net",
    "items": [
        {
            "id": "https://smilin.net/2023/10/27/rust_learning_02/",
            "url": "https://smilin.net/2023/10/27/rust_learning_02/",
            "title": "Rust 學習紀錄[2] = Rust 的 NPM",
            "date_published": "2023-10-27T13:00:00.000Z",
            "content_html": "<p>讓我們接著原本的進度繼續</p>\n<span id=\"more\"></span>\n\n<br>\n\n<h1 id=\"Cargo\"><a href=\"#Cargo\" class=\"headerlink\" title=\"Cargo\"></a>Cargo</h1><br>\n\n<p><code>Cargo</code> 是 <code>Rust</code> 的專案建置工具以及套件管理器<br>恩..聽起來是個 <code>npm</code></p>\n<p>我們在安裝 <code>rustup</code> 時已經一併安裝了 <code>Cargo</code><br>使用 <code>cargo --version</code> 來確認是否正確安裝</p>\n<pre><code>cargo --version // cargo 1.73.0 (9c4383fb5 2023-08-26)\n</code></pre>\n<p>沒問題的話，接著使用 <code>Cargo</code> 創建跟昨天相似的專案。</p>\n<br>\n\n<h1 id=\"創建專案\"><a href=\"#創建專案\" class=\"headerlink\" title=\"創建專案\"></a>創建專案</h1><br>\n\n<p>在專案目錄(rust_project)下輸入創建專案的指令</p>\n<p><code>cargo new _02_hello_cargo</code></p>\n<p>現在我們有名為 <code>_02_hello_cargo</code> 的資料夾，裡面結構如下</p>\n<pre><code>src\n  main.rs\n.gitignore\nCargo.toml\n</code></pre>\n<p><code>src</code> - 常見程式開發檔案目錄，看就知道</p>\n<p><code>src\\main.rs</code> - 主程式</p>\n<p><code>.gitignore</code> - git 的描述文件，主要功能是防止裡面提到的檔案在 git 傳輸時被包進去(Ex:log&#x2F;target)</p>\n<p><code>Cargo.toml</code> - 打開來看了下，應該是專案描述文件，對應 node 的 <code>package.json</code></p>\n<br>\n\n<h2 id=\"編譯-build\"><a href=\"#編譯-build\" class=\"headerlink\" title=\"編譯(build)\"></a>編譯(build)</h2><br>\n\n<p>試著 build 起這個專案看看<br><code>cargo build</code></p>\n<p>執行後，專案內多出了幾個檔案</p>\n<pre><code>target\n  debug\n    _02_hello_cargo.exe\n    more debug files...\n  .rustc_info.json\n  CACHEDIR.TAG\nCargo.lock\n</code></pre>\n<p><code>Cargo.lock</code> - 對應 node 的 <code>package-lock.json</code></p>\n<p><code>target\\debug\\_02_hello_cargo.exe</code> - 我們產出的執行檔，debug 大概是 building 的默認方式，之後應該會有相對嚴謹的方法</p>\n<pre><code>.\\target\\debug\\_02_hello_cargo // Hello, world!\n</code></pre>\n<br>\n\n<h2 id=\"編譯並運行-run\"><a href=\"#編譯並運行-run\" class=\"headerlink\" title=\"編譯並運行(run)\"></a>編譯並運行(run)</h2><br>\n\n<p>Cargo 有提供一種命令，可以將編譯與運行合併成一個指令</p>\n<pre><code>cargo run // Hello, world!\n</code></pre>\n<p>如果開發檔案沒有修改，<code>cargo run</code> 不會重建 target<br>加上合併兩個步驟，比 <code>cargo build</code> 方便許多。</p>\n<br>\n\n<h2 id=\"檢查-check\"><a href=\"#檢查-check\" class=\"headerlink\" title=\"檢查(check)\"></a>檢查(check)</h2><br>\n\n<p>除了編譯與運行，Cargo 當然也提供了檢查命令</p>\n<pre><code>cargo check\n  /**\n    Checking _02_hello_cargo v0.1.0(C:\\my\\01\\git\\rust\\_02_hello_cargo)\n    Finished dev [unoptimized + debuginfo] target(s) in 0.07s\n  **/\n</code></pre>\n<p>單純的 <code>check</code> 比 <code>build</code> 快上許多<br>在自動化部屬等一類場景中廣泛運用。</p>\n<br>\n\n<h2 id=\"正式編譯-release\"><a href=\"#正式編譯-release\" class=\"headerlink\" title=\"正式編譯(release)\"></a>正式編譯(release)</h2><br>\n\n<pre><code>cargo build --release\n  /**\n    Compiling _02_hello_cargo v0.1.0 (C:\\my\\01\\git\\rust\\_02_hello_cargo)\n        Finished release [optimized] target(s) in 0.36s\n  **/\n</code></pre>\n<p>使用 <code>--release</code> building 的檔案會放在 <code>target\\release</code><br>與 debug 版本不同，release 的編譯過程比較久，但會最佳化產出的結果</p>\n<p>因此，使用 debug 開發可以有效降低等待編譯的時間<br>需要發佈檔案時，再使用 release。</p>\n<br>\n\n<h1 id=\"今日小結\"><a href=\"#今日小結\" class=\"headerlink\" title=\"今日小結\"></a>今日小結</h1><br>\n\n<p><code>cargo --version</code> 驗證版本</p>\n<p><code>cargo new &#123;project_name&#125;</code> 創建專案</p>\n<p><code>cargo build</code> 編譯專案</p>\n<p><code>cargo run</code> 編譯&amp;運行專案</p>\n<p><code>cargo check</code> 驗證專案</p>\n<p><code>cargo build --release</code> 正式版本的編譯</p>\n",
            "tags": [
                "Rust"
            ]
        },
        {
            "id": "https://smilin.net/2023/10/27/rust_learning_01/",
            "url": "https://smilin.net/2023/10/27/rust_learning_01/",
            "title": "Rust 學習紀錄[1] = 日誌中的教學",
            "date_published": "2023-10-27T10:00:00.000Z",
            "content_html": "<p>工欲善其事，必先利其器<br>想學一門語言，要從一篇教學文檔找起</p>\n<p><a href=\"https://doc.rust-lang.org/book/\">官方文檔</a></p>\n<p>恩，官方文檔看起來挺不錯的，就這個吧</p>\n<p>這篇文撰寫當下，文檔對應 Rust 版本為 <code>Rust 1.67.1 (released 2023-02-09) or later</code><br>如果因為版本不同造成閱讀的困擾的話，可以在學會安裝 Rust 後自行降版學習。</p>\n<span id=\"more\"></span>\n\n<br>\n\n<h1 id=\"安裝\"><a href=\"#安裝\" class=\"headerlink\" title=\"安裝\"></a>安裝</h1><br>\n\n<p>說是 Rust，其實第一個遇到的是 <code>rustup</code></p>\n<p><a href=\"https://www.rust-lang.org/tools/install\">Window 安裝 rustup</a></p>\n<p>安裝過程一直 Enter 就好，之後在 cmd 下 <code>rustc --version</code></p>\n<p>得到版本號 <code>rustc 1.73.0 (cc66ad468 2023-10-03)</code>，表示安裝成功</p>\n<p>其他比較常用的指令還有</p>\n<p>更新 Rust 版本 - <code>rustup update</code></p>\n<p>卸載 Rust 跟 rustup - <code>rustup self uninstall</code></p>\n<p>查看 Rust Doc 本機離線版 - <code>rustup doc</code></p>\n<br>\n\n<p>根據 Rust 自己的說明，約莫每兩周會有一次小版更新<br>也因此，除非目標是維護專案，理論上更新版本 &amp; 追蹤文檔改動會很頻繁。</p>\n<br>\n\n<h1 id=\"HELLO-RUST！\"><a href=\"#HELLO-RUST！\" class=\"headerlink\" title=\"HELLO RUST！\"></a>HELLO RUST！</h1><br>\n\n<p>首先讓我們創建一個資料夾</p>\n<p><code>rust_project</code></p>\n<p>往後任何的 Rust 程式都會放在這個資料夾下<br>現在在專案資料夾下新增我們要製作的第一個 Rust 程式</p>\n<p><code>rust_project\\_01_hello_rust\\main.rs</code></p>\n<pre><code>fn main() &#123;\n    println!(&quot;Hello, Rust!&quot;);\n&#125;\n</code></pre>\n<p>之後打開 cmd ，輸入以下</p>\n<pre><code>rustc main.rs\n.\\main.exe // 印出 Hello, Rust!\n</code></pre>\n<p>如此，我們完成了第一隻 Rust 程式。<br><del>超快！！</del><br><del>嘛、畢竟是 Hello World 嘛</del></p>\n<br>\n\n<h1 id=\"感想\"><a href=\"#感想\" class=\"headerlink\" title=\"感想\"></a>感想</h1><br>\n\n<p>首先注意到的，是執行的指令拆成了兩個<br>分別是 <strong>編譯</strong> 的行為與 <strong>執行</strong> 的行為</p>\n<p>編譯出來的檔案是 <code>.exe</code>，意味著寫好的程式不需要借助 Rust 就能運行<br>這在筆者之前的經驗中是比較少見的</p>\n<p>同樣被編譯出來的還有一個 <code>main.pdb</code><br>暫時不知道是做甚麼用的，之後學到再回來更新</p>\n<br>\n\n<p><code>println!();</code><br>在這段酷似 JAVASCRIPT 風格的 JAVA 式命名輸出語法上，突兀的出現了個 <code>!</code></p>\n<p>這是 Rust 的 <code>macro</code><br>比起 Rust 的 <code>function</code>，<code>macro</code> 更接近 JAVASCRIPT 的 <code>function</code></p>\n<p>Rust 中，存在 <code>fn(function)</code> 跟 <code>macro_rules(macro)</code><br>他們的差別主要在於 <code>function(函式)</code> 的參數數量是固定的<br>而 <code>macro(巨集)</code> 則可以動態傳入參數</p>\n<p><code>println</code> 預期要能夠傳入多個參數，當他要做格式化傳輸時</p>\n<pre><code>println!(&quot;Hello, Macro! My name is &#123;&#125;!&quot;, &quot;Smilin&quot;)\n</code></pre>\n<p>比起 <code>fn</code>，<code>macro_rules</code> 顯然更符合需求。</p>\n<br>\n\n<h1 id=\"今日小結\"><a href=\"#今日小結\" class=\"headerlink\" title=\"今日小結\"></a>今日小結</h1><br>\n\n<p><code>rustc --version</code> 驗證版本</p>\n<p><code>rustup update</code> 更新 Rust</p>\n<p><code>rustup self uninstall</code> 反安裝 Rust</p>\n<p><code>rustup doc</code> 運行 Rust Local Doc</p>\n<p><code>rustc main.rs</code> 編譯 rs 檔</p>\n<p><code>.pdb</code> ???</p>\n<p><code>macro</code> 巨集 &#x2F; 宏，可以傳入動態參數</p>\n<p><code>function</code> 函式 &#x2F; 方法，宣告時就要規範好參數數量與型別</p>\n<br>\n\n<h1 id=\"資料參考\"><a href=\"#資料參考\" class=\"headerlink\" title=\"資料參考\"></a>資料參考</h1><br>\n\n<p><a href=\"https://doc.rust-lang.org/book/\">Rust 官方文檔</a></p>\n<p><a href=\"https://www.rust-lang.org/tools/install\">Window 安裝 rustup</a></p>\n",
            "tags": [
                "Rust"
            ]
        },
        {
            "id": "https://smilin.net/2023/10/27/rust_learning_00/",
            "url": "https://smilin.net/2023/10/27/rust_learning_00/",
            "title": "Rust 學習紀錄[0] = 前言",
            "date_published": "2023-10-27T04:00:00.000Z",
            "content_html": "<p><img src=\"https://upload.wikimedia.org/wikipedia/commons/thumb/d/d5/Rust_programming_language_black_logo.svg/216px-Rust_programming_language_black_logo.svg.png\" alt=\"Rust\"></p>\n<br>\n\n<p>2021 年 2 月，Rust 基金會成立</p>\n<p>以 AWS、GOOGLE 等多家資訊巨頭為首<br>因為看好 Rust 兼顧了高效能 &amp; 安全性而投資<br>使得 Rust 這兩年有了巨大的成長。</p>\n<p>這也是為什麼，近幾年工程師無論如何不願意<br>多少也會聽過 Rust 的名號，隱隱有與 C++ 並駕齊驅的勢頭。</p>\n<span id=\"more\"></span>\n\n<p>筆者平常習慣 node.js or java 的開發，接觸 Rust 算是偶然<br>剛好想嘗試所謂能真正實現高效能程式碼(沒碰過 C++)</p>\n<p>做為學習動力，一方面會將自己的學習過程發布在 blog<br>另一方面打算在學到一個階段後，試著用 Rust 構建一個微型社群平台，當作目標。</p>\n<p>本次系列與其說是教學，更像是日記一類的東西，如果能激起看這篇文的你的興趣的話，我會很高興的。</p>\n",
            "tags": [
                "Rust"
            ]
        },
        {
            "id": "https://smilin.net/2023/09/15/deepCopyAndShallowCopy/",
            "url": "https://smilin.net/2023/09/15/deepCopyAndShallowCopy/",
            "title": "淺談 js 深拷貝與淺拷貝的差異",
            "date_published": "2023-09-15T04:00:00.000Z",
            "content_html": "<h1 id=\"Deep-copy-和-Shallow-copy\"><a href=\"#Deep-copy-和-Shallow-copy\" class=\"headerlink\" title=\"Deep copy 和 Shallow copy\"></a>Deep copy 和 Shallow copy</h1><br>\n\n<p>先來個考題：</p>\n<pre><code>a = &#123; foo: &quot;bar&quot; &#125;;\nb = a;\nb.foo = &quot;baz&quot;;\n\nconsole.log(a.foo); // 印出?\n</code></pre>\n<span id=\"more\"></span>\n\n<details>\n<summary>答案</summary>\n<br>\nbaz\n</details>\n\n<p><br><br></p>\n<p>下一題：</p>\n<pre><code>a = &#123; foo: &quot;bar&quot; &#125;;\nb = structuredClone(a); // 深拷貝\nb.foo = &quot;baz&quot;;\n\nconsole.log(a.foo); // 印出?\n</code></pre>\n<details>\n<summary>答案</summary>\n<br>\nbar  \n<br><br>\n深拷貝(Deep Copy) 可以將內層對象一併拷貝  \n</details>\n\n<p><br><br></p>\n<hr>\n<br>\n\n<h2 id=\"Shallow-copy\"><a href=\"#Shallow-copy\" class=\"headerlink\" title=\"Shallow copy\"></a>Shallow copy</h2><br>\n\n<p>淺拷貝(Shallow Copy) 與深拷貝同樣是用來拷貝物件層級，避免指向同一記憶體位置</p>\n<p>與深拷貝不同的是，淺拷貝只會複製第一層的對象，如果是 <code>Object.Object</code> 的結構就沒轍。</p>\n<br>\n\n<h3 id=\"Object-assign\"><a href=\"#Object-assign\" class=\"headerlink\" title=\"Object.assign\"></a>Object.assign</h3><br>\n\n<p><code>Object.assign</code> 屬於淺拷貝(Shallow Copy)<br>在上述案例中，可以得到跟深拷貝一樣的結果</p>\n<pre><code>a = &#123; foo: &#123; fpp: &quot;bar&quot; &#125; &#125;;\nb = Object.assign(&#123;&#125;, a);\nb.foo.fpp = &quot;baz&quot;;\n\nconsole.log(a.foo.fpp); // 印出baz\n</code></pre>\n<br>\n\n<h3 id=\"解構賦值\"><a href=\"#解構賦值\" class=\"headerlink\" title=\"解構賦值\"></a>解構賦值</h3><br>\n\n<p>解構賦值是 <code>ES6</code> 以後的語法糖，同樣屬於淺拷貝</p>\n<pre><code>const a = &#123; b: 1 &#125;;\nconst c = &#123; ...a &#125;; // 解構賦值\nc.b = 2;\nconsole.log(a); // &#123; b: 1 &#125;\n</code></pre>\n<p>得益於其精簡的代碼，實務上很常使用。</p>\n<p><br><br></p>\n<hr>\n<br>\n\n<h2 id=\"Deep-copy\"><a href=\"#Deep-copy\" class=\"headerlink\" title=\"Deep copy\"></a>Deep copy</h2><br>\n\n<p>與前面提到的淺拷貝不同，深拷貝對於深層結構也能一併複製</p>\n<br>\n\n<h3 id=\"早期的深拷貝\"><a href=\"#早期的深拷貝\" class=\"headerlink\" title=\"早期的深拷貝\"></a>早期的深拷貝</h3><pre><code>JSON.parse(JSON.stringify());\n</code></pre>\n<p>這個寫法大致上有以下缺點：</p>\n<ul>\n<li>忽略 <code>function</code></li>\n<li>忽略原形鏈</li>\n<li>忽略 <code>undefined</code></li>\n<li>子層太多會導致 <code>stack overflow</code></li>\n</ul>\n<p>儘管如此，由於已經可以處理大多狀況<br>如果不是為了性能或是特殊邏輯，此寫法已經夠用，是常見的深拷貝實現。</p>\n<br>\n\n<h3 id=\"structuredClone\"><a href=\"#structuredClone\" class=\"headerlink\" title=\"structuredClone\"></a>structuredClone</h3><p><code>structuredClone</code> 是 <code>node.js</code> 17 版以後支援的官方深拷貝實現</p>\n<p>目前各大瀏覽器默認支援此語法</p>\n<p><img src=\"https://i.imgur.com/tPXjO1o.png\" alt=\"1\"></p>\n<br>\n\n<p><code>structuredClone</code> 存在一些限制</p>\n<p>不允許結構中存在 <code>Error</code> 、 <code>Function</code> 以及 <code>DOM</code> 對象</p>\n<p>不保留 <code>RegExp</code> 對象的 <code>lastIndex</code></p>\n<p>不保留 <code>read-only</code> 等描述符，即無法限制 <code>setters</code> <code>getters</code></p>\n<p>不保留原形鏈</p>\n",
            "tags": [
                "javascript"
            ]
        }
    ]
}